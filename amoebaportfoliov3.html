<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Portfolio Amoeba Simulator</title>
    <style>
        body { 
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
            width: 100vw;
            height: 100vh;
        }
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #portfolio-status {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 16px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            max-width: 300px;
            width: calc(100% - 40px);
            backdrop-filter: blur(5px);
        }
        #timeline {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: calc(100% - 40px);
            max-width: 1200px;
            height: 80px;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }
        #metrics {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 16px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            max-width: 300px;
            width: calc(100% - 40px);
            backdrop-filter: blur(5px);
        }
        .gain { color: #4CAF50; }
        .loss { color: #f44336; }
        canvas {
            touch-action: none;
            display: block;
        }
        .dialog {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
            backdrop-filter: blur(5px);
            width: 90%;
            max-width: 400px;
        }
        button {
            background: #333;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: background 0.2s;
        }
        button:hover {
            background: #444;
        }
        #add-position-form {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }
        #add-position-form input,
        #add-position-form select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            margin: 5px 0;
            width: 100%;
            font-size: 14px;
        }
        #add-position-form input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        #add-position-form button {
            width: 100%;
            margin-top: 10px;
        }

        /* Mobile-specific styles */
        @media (max-width: 768px) {
            #portfolio-status,
            #metrics {
                position: fixed;
                max-width: none;
                width: 100%;
                left: 0;
                right: 0;
                border-radius: 0;
                transform: translateY(-100%);
                transition: transform 0.3s ease;
            }
            #portfolio-status.visible,
            #metrics.visible {
                transform: translateY(0);
            }
            #metrics {
                top: auto;
                bottom: 120px;
            }
            #timeline {
                height: 60px;
                bottom: 10px;
            }
            .dialog {
                width: 95%;
            }
        }

        #instruction-prompt {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
            text-align: center;
            animation: blink 2s infinite;
            text-shadow: 0 0 10px rgba(100, 150, 255, 0.5);
            pointer-events: none;
        }

        #instruction-overlay {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            z-index: 2000;
            max-width: 600px;
            width: 90%;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            box-shadow: 0 0 20px rgba(100, 150, 255, 0.2);
        }

        #instruction-overlay h2 {
            color: rgb(100, 150, 255);
            margin-top: 0;
            margin-bottom: 20px;
            text-align: center;
        }

        #instruction-overlay .section {
            margin-bottom: 20px;
        }

        #instruction-overlay .section-title {
            color: rgb(100, 150, 255);
            font-weight: bold;
            margin-bottom: 10px;
        }

        #instruction-overlay kbd {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-family: monospace;
            margin: 0 2px;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="instruction-prompt">Press <kbd>I</kbd> for Instructions</div>
    <div id="instruction-overlay">
        <h2>Amoeba Portfolio Simulator Instructions</h2>
        
        <div class="section">
            <div class="section-title">Navigation Controls</div>
            <p>
                • <kbd>Left Mouse</kbd> + Drag: Pan the view<br>
                • <kbd>Right Mouse</kbd> or <kbd>Shift</kbd> + <kbd>Left Mouse</kbd> + Drag: Rotate the view<br>
                • <kbd>Mouse Wheel</kbd>: Zoom in/out
            </p>
        </div>

        <div class="section">
            <div class="section-title">Amoeba Controls</div>
            <p>
                • Mouse cursor controls amoeba movement by default<br>
                • <kbd>M</kbd>: Toggle between mouse control and autonomous mode
            </p>
        </div>

        <div class="section">
            <div class="section-title">Interface Controls</div>
            <p>
                • <kbd>H</kbd>: Hide/Show all UI elements<br>
                • <kbd>I</kbd>: Toggle this instruction overlay<br>
                • Click on cells to view and close positions
            </p>
        </div>

        <div class="section">
            <div class="section-title">Cell Information</div>
            <p>
                • Green cells represent gains<br>
                • Red cells represent losses<br>
                • Cell size indicates position value<br>
                • Dollar values are shown on each cell
            </p>
        </div>

        <p style="text-align: center; margin-top: 30px; color: rgba(255,255,255,0.6);">
            Press <kbd>I</kbd> again to close
        </p>
    </div>
    <div id="portfolio-status">
        <h3>Portfolio Status</h3>
        <p>Current Value: $<span id="currentValue">0</span></p>
        <p>Total Gain/Loss: $<span id="totalGainLoss">0</span></p>
        <p>Number of Positions: <span id="positionCount">0</span></p>
        
        <div id="add-position-form">
            <h4>Add New Position</h4>
            <input type="number" id="position-amount" placeholder="Amount" step="0.01" min="0">
            <select id="position-type">
                <option value="long">Long</option>
                <option value="short">Short</option>
            </select>
            <button id="add-position">Add Position</button>
        </div>
    </div>
    
    <div id="metrics">
        <h3>Performance Metrics</h3>
        <p>Win Rate: <span id="winRate">0</span>%</p>
        <p>Avg Gain: $<span id="avgGain">0</span></p>
        <p>Avg Loss: $<span id="avgLoss">0</span></p>
    </div>
    
    <div id="timeline"></div>
    
    <div id="closePositionDialog" class="dialog">
        <h3>Close Position</h3>
        <p>Symbol: <span id="closeSymbol"></span></p>
        <p>Current G/L: <span id="closeGainLoss"></span></p>
        <button onclick="confirmClosePosition()">Confirm Close</button>
        <button onclick="cancelClosePosition()">Cancel</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <script>
        // Define classes first
        class Portfolio {
            constructor() {
                this.openValue = 0;
                this.realizedValue = 0;
                this.totalValue = 0;
                this.valueHistory = [];
                this.positions = [];
            }

            getCurrentValue() {
                return this.totalValue;
            }

            getTotalGainLoss() {
                // Sum up gain/loss from open positions
                const openPositionsGainLoss = positionHistory.open.reduce((sum, pos) => sum + pos.gainLoss, 0);
                
                // Add realized gains/losses
                return openPositionsGainLoss + this.realizedValue;
            }

            updateValue() {
                // Calculate total value of open positions
                this.openValue = positionHistory.open.reduce((sum, pos) => sum + pos.marketValue, 0);
                this.totalValue = this.openValue + this.realizedValue;
                
                this.valueHistory.push({
                    timestamp: new Date(),
                    openValue: this.openValue,
                    realizedValue: this.realizedValue,
                    totalValue: this.totalValue
                });

                updateDisplay();
            }

            addPosition(position) {
                this.positions.push(position);
                this.updateValue();
            }

            getHistory() {
                return this.valueHistory;
            }
        }

        class Position {
            constructor(data) {
                this.symbol = data.symbol;
                this.marketValue = parseFloat(data.marketValue);
                this.gainLoss = parseFloat(data.gainLoss);
                this.isOpen = true;
                this.closePrice = null;
                this.closeDate = null;
                this.realizedGainLoss = 0;
            }
        }

        // Then declare variables
        let amoeba;
        let timelineVisualizer;
        let performanceMetrics;
        let gainCells = [];
        let lossCells = [];
        let zoomLevel = 1;
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let isRotating = false;
        let rotation = 0;
        let selectedCluster = null;

        // Position tracking
        let positionHistory = {
            open: [],
            closed: [],
            realizedGains: 0,
            realizedLosses: 0,
            history: []
        };

        // Initialize portfolio after class definitions
        const portfolio = new Portfolio();

        function preload() {
            // Load the CSV file
            loadTable('option_holdings.csv', 'csv', 'header', (table) => {
                for (let row of table.rows) {
                    const position = new Position({
                        symbol: row.get('symbol'),
                        marketValue: row.get('Market Value'),
                        gainLoss: row.get('Gain/Loss')
                    });
                    positionHistory.open.push(position);
                }
                
                // Initialize portfolio after loading data
                portfolio.updateValue();
                createClusters();
            });
        }

        function setup() {
            const canvas = createCanvas(windowWidth, windowHeight);
            canvas.parent('canvas-container');
            
            amoeba = new Amoeba(width/2, height/2);
            timelineVisualizer = new TimelineVisualizer(width * 0.1, height * 0.8, width * 0.8, height * 0.15);
            performanceMetrics = new PerformanceMetrics();
            
            // Load saved history if exists
            loadHistory();
            
            // Setup event listeners
            document.getElementById('add-position').addEventListener('click', () => {
                const amount = parseFloat(document.getElementById('position-amount').value);
                const type = document.getElementById('position-type').value;
                
                // Create new position with proper data structure
                const position = new Position({
                    symbol: type.toUpperCase() + '_' + Date.now(),
                    marketValue: amount,
                    gainLoss: 0  // Initial gain/loss is 0
                });
                
                // Add to open positions
                positionHistory.open.push(position);
                
                // Add to history
                positionHistory.history.push({
                    type: 'open',
                    symbol: position.symbol,
                    gainLoss: 0,
                    timestamp: new Date()
                });
                
                // Create new cluster
                const cluster = new Cell(position, type === 'long');
                if (type === 'long') {
                    gainCells.push(cluster);
                } else {
                    lossCells.push(cluster);
                }
                
                // Update portfolio
                portfolio.addPosition(position);
                
                // Clear form
                document.getElementById('position-amount').value = '';
                
                // Save state
                saveHistory();
            });

            // Initial window resize to set correct dimensions
            windowResized();
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            
            // Update timeline visualizer dimensions
            if (timelineVisualizer) {
                timelineVisualizer.x = windowWidth * 0.1;
                timelineVisualizer.y = windowHeight * 0.8;
                timelineVisualizer.width = windowWidth * 0.8;
                timelineVisualizer.height = windowHeight * 0.15;
            }
            
            // Center amoeba
            if (amoeba) {
                amoeba.pos.x = windowWidth / 2;
                amoeba.pos.y = windowHeight / 2;
            }
            
            // Reset pan and zoom on resize
            panX = 0;
            panY = 0;
            zoomLevel = 1;
            rotation = 0;
        }

        // Add mouseWheel function for zoom
        function mouseWheel(event) {
            event.preventDefault();
            zoomLevel *= event.delta > 0 ? 0.95 : 1.05;
            zoomLevel = constrain(zoomLevel, 0.5, 5);
            return false;
        }

        function createClusters() {
            positionHistory.open.forEach(position => {
                if (position.gainLoss > 0) {
                    gainCells.push(new Cell(position, true));
                } else {
                    lossCells.push(new Cell(position, false));
                }
            });
        }

        class Cell {
            constructor(position, isGain) {
                this.position = position;
                this.isGain = isGain;
                this.pos = createVector(
                    width/2 + random(-width/3, width/3),
                    height/2 + random(-height/3, height/3)
                );
                this.vel = p5.Vector.random2D().mult(2);
                this.acc = createVector(0, 0);
                this.size = map(abs(position.marketValue), 0, 100, 15, 40);
                this.phase = random(TWO_PI);
                this.rotationPhase = random(TWO_PI);
                this.pulseSpeed = random(0.02, 0.05);
                this.maxSpeed = 2;
                this.maxForce = 0.1;
                this.wanderAngle = random(TWO_PI);
                this.wanderRadius = 30;
                this.wanderOffset = 20;
                this.marketValue = abs(position.marketValue);
            }

            update() {
                // Wander behavior
                this.wanderAngle += random(-0.3, 0.3);
                const wanderPoint = p5.Vector.fromAngle(this.wanderAngle);
                wanderPoint.mult(this.wanderRadius);
                wanderPoint.add(p5.Vector.mult(this.vel.copy().normalize(), this.wanderOffset));
                
                const target = p5.Vector.add(this.pos, wanderPoint);
                const desired = p5.Vector.sub(target, this.pos);
                desired.normalize();
                desired.mult(this.maxSpeed);
                
                const steer = p5.Vector.sub(desired, this.vel);
                steer.limit(this.maxForce);
                this.acc.add(steer);

                // Avoid other cells
                const allCells = [...gainCells, ...lossCells];
                allCells.forEach(other => {
                    if (other !== this) {
                        const d = p5.Vector.dist(this.pos, other.pos);
                        if (d < 100 && d > 0) {
                            const force = p5.Vector.sub(this.pos, other.pos);
                            force.normalize();
                            force.mult(0.3);
                            this.acc.add(force);
                        }
                    }
                });

                // Update movement
                this.vel.add(this.acc);
                this.vel.limit(this.maxSpeed);
                this.pos.add(this.vel);
                this.acc.mult(0);

                // Wrap around screen edges
                const margin = this.size;
                if (this.pos.x < -margin) this.pos.x = width + margin;
                if (this.pos.x > width + margin) this.pos.x = -margin;
                if (this.pos.y < -margin) this.pos.y = height + margin;
                if (this.pos.y > height + margin) this.pos.y = -margin;

                // Update animations
                this.rotationPhase += 0.02;
                this.phase += this.pulseSpeed;
            }

            display() {
                push();
                translate(this.pos.x, this.pos.y);
                rotate(this.rotationPhase);

                // Draw glow effect
                for (let i = 3; i > 0; i--) {
                    noStroke();
                    const alpha = map(i, 3, 0, 30, 100);
                    const color = this.isGain ? [100, 255, 100, alpha] : [255, 100, 100, alpha];
                    fill(...color);
                    const size = this.size + i * 5 + sin(this.phase) * 3;
                    circle(0, 0, size);
                }

                // Draw main cell
                const mainColor = this.isGain ? color(100, 255, 100) : color(255, 100, 100);
                fill(mainColor);
                const mainSize = this.size + sin(this.phase) * 2;
                circle(0, 0, mainSize);

                // Add highlight
                fill(255, 100);
                circle(-this.size/4, -this.size/4, this.size/3);

                // Draw value
                fill(255);
                noStroke();
                textAlign(CENTER, CENTER);
                textSize(10);
                text('$' + abs(this.marketValue).toFixed(0), 0, 0);

                pop();
            }

            containsPoint(x, y) {
                return dist(x, y, this.pos.x, this.pos.y) < this.size/2;
            }
        }

        class Amoeba {
            constructor(x, y) {
                this.pos = createVector(x, y);
                this.vel = createVector(0, 0);
                this.acc = createVector(0, 0);
                this.target = null;  // Current cell being chased
                this.radius = 50;
                this.points = [];
                this.tentacles = [];
                this.noiseOffset = random(1000);
                this.maxSpeed = 4;
                this.maxForce = 0.2;
                this.searchRadius = 200;  // Radius to look for cells
                this.followMouse = true;  // By default, follow the mouse
                
                // Initialize body points
                const numPoints = 36;
                for (let i = 0; i < numPoints; i++) {
                    const angle = map(i, 0, numPoints, 0, TWO_PI);
                    this.points.push({
                        angle: angle,
                        radius: this.radius,
                        noiseOffset: random(1000)
                    });
                }
                
                // Initialize tentacles
                const numTentacles = 8;
                for (let i = 0; i < numTentacles; i++) {
                    const angle = map(i, 0, numTentacles, 0, TWO_PI);
                    this.tentacles.push({
                        angle: angle,
                        segments: [],
                        noiseOffset: random(1000)
                    });
                    
                    const numSegments = 5;
                    for (let j = 0; j < numSegments; j++) {
                        const segmentLength = map(j, 0, numSegments, this.radius * 0.4, this.radius * 0.1);
                        this.tentacles[i].segments.push({
                            length: segmentLength,
                            angle: angle,
                            noiseOffset: random(1000)
                        });
                    }
                }
            }

            update() {
                // Get mouse position in world space
                const mousePos = createVector(
                    (mouseX - width/2) / zoomLevel + width/2 - panX,
                    (mouseY - height/2) / zoomLevel + height/2 - panY
                );

                if (this.followMouse) {
                    // Follow mouse cursor
                    const desired = p5.Vector.sub(mousePos, this.pos);
                    const d = desired.mag();
                    
                    if (d < 10) {
                        // If very close to mouse, slow down
                        desired.setMag(map(d, 0, 10, 0, this.maxSpeed));
                    } else {
                        desired.setMag(this.maxSpeed);
                    }
                    
                    const steer = p5.Vector.sub(desired, this.vel);
                    steer.limit(this.maxForce);
                    this.acc.add(steer);
                } else if (!this.target) {
                    // Find nearest cell if not following mouse and no target
                    let nearestDist = this.searchRadius;
                    const allCells = [...gainCells, ...lossCells];
                    allCells.forEach(cell => {
                        const d = p5.Vector.dist(this.pos, cell.pos);
                        if (d < nearestDist) {
                            nearestDist = d;
                            this.target = cell;
                        }
                    });
                }

                // If not following mouse and has target, chase it
                if (!this.followMouse && this.target) {
                    const d = p5.Vector.dist(this.pos, this.target.pos);
                    if (d < this.searchRadius) {
                        const desired = p5.Vector.sub(this.target.pos, this.pos);
                        desired.normalize();
                        desired.mult(this.maxSpeed);
                        const steer = p5.Vector.sub(desired, this.vel);
                        steer.limit(this.maxForce);
                        this.acc.add(steer);
                    } else {
                        this.target = null;
                    }
                }
                
                // Update position
                this.vel.add(this.acc);
                this.vel.limit(this.maxSpeed);
                this.pos.add(this.vel);
                this.acc.mult(0);
                
                // Wrap around screen edges
                if (this.pos.x < -this.radius) this.pos.x = width + this.radius;
                if (this.pos.x > width + this.radius) this.pos.x = -this.radius;
                if (this.pos.y < -this.radius) this.pos.y = height + this.radius;
                if (this.pos.y > height + this.radius) this.pos.y = -this.radius;

                // Update body shape
                this.points.forEach(point => {
                    const noiseVal = noise(point.noiseOffset + frameCount * 0.03);
                    point.radius = this.radius + map(noiseVal, 0, 1, -10, 10);
                    point.noiseOffset += 0.02;
                });

                // Update tentacles to point towards target
                this.tentacles.forEach(tentacle => {
                    let targetAngle = tentacle.angle;
                    if (this.followMouse) {
                        targetAngle = atan2(
                            mousePos.y - this.pos.y,
                            mousePos.x - this.pos.x
                        );
                    } else if (this.target) {
                        targetAngle = atan2(
                            this.target.pos.y - this.pos.y,
                            this.target.pos.x - this.pos.x
                        );
                    }
                    
                    tentacle.segments.forEach(segment => {
                        const noiseVal = noise(segment.noiseOffset + frameCount * 0.03);
                        segment.angle = lerp(segment.angle, targetAngle, 0.1) + map(noiseVal, 0, 1, -0.4, 0.4);
                        segment.noiseOffset += 0.02;
                    });
                });
            }

            display() {
                push();
                translate(this.pos.x, this.pos.y);

                // Draw tentacles
                this.tentacles.forEach(tentacle => {
                    let prevX = 0;
                    let prevY = 0;
                    
                    tentacle.segments.forEach((segment, i) => {
                        const x = prevX + cos(segment.angle) * segment.length;
                        const y = prevY + sin(segment.angle) * segment.length;
                        
                        stroke(100, 150, 255, map(i, 0, tentacle.segments.length, 150, 50));
                        strokeWeight(map(i, 0, tentacle.segments.length, 8, 2));
                        line(prevX, prevY, x, y);
                        
                        prevX = x;
                        prevY = y;
                    });
                });

                // Draw main cell body with gradient
                for (let i = 0; i < 3; i++) {
                    beginShape();
                    noStroke();
                    for (let j = 0; j < this.points.length; j++) {
                        const point = this.points[j];
                        const alpha = map(sin(point.angle), -1, 1, 100, 150);
                        fill(100, 150, 255, alpha - i * 30);
                        const x = cos(point.angle) * (point.radius - i * 5);
                        const y = sin(point.angle) * (point.radius - i * 5);
                        curveVertex(x, y);
                    }
                    const firstPoint = this.points[0];
                    const x = cos(firstPoint.angle) * (firstPoint.radius - i * 5);
                    const y = sin(firstPoint.angle) * (firstPoint.radius - i * 5);
                    curveVertex(x, y);
                    endShape(CLOSE);
                }

                // Add highlight effect
                beginShape();
                noStroke();
                for (let i = 0; i < this.points.length; i++) {
                    const point = this.points[i];
                    const alpha = map(sin(point.angle), -1, 1, 100, 150);
                    fill(255, alpha);
                    const x = cos(point.angle) * point.radius * 0.7;
                    const y = sin(point.angle) * point.radius * 0.7;
                    curveVertex(x, y);
                }
                const firstPoint = this.points[0];
                const x = cos(firstPoint.angle) * firstPoint.radius * 0.7;
                const y = sin(firstPoint.angle) * firstPoint.radius * 0.7;
                curveVertex(x, y);
                endShape(CLOSE);

                pop();
            }

            containsPoint(x, y) {
                const d = dist(x, y, this.pos.x, this.pos.y);
                return d < this.radius;
            }
        }

        class TimelineVisualizer {
            constructor(x, y, width, height) {
                this.visible = true;
                this.events = [];
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }

            update() {
                this.events = positionHistory.history.map((event, i) => ({
                    ...event,
                    x: map(i, 0, positionHistory.history.length - 1, this.x, this.x + this.width)
                }));
            }

            display(history) {
                if (!this.visible) return;
                
                push();
                translate(this.x, this.y);
                
                // Draw timeline base
                stroke(100);
                line(0, 0, this.width, 0);
                
                // Draw events
                this.events.forEach(event => {
                    noStroke();
                    if (event.type === 'open') fill(255);
                    else fill(event.gainLoss > 0 ? color(0,255,0) : color(255,0,0));
                    
                    circle(event.x, 0, 10);
                    
                    // Draw symbol and value
                    push();
                    translate(event.x, 0);
                    rotate(-PI/4);
                    fill(255);
                    textAlign(LEFT);
                    textSize(12);
                    text(event.symbol, 10, 0);
                    text('$' + abs(event.gainLoss).toFixed(2), 10, 15);
                    pop();
                });
                
                pop();
            }
        }

        class PerformanceMetrics {
            constructor() {
                this.metrics = {
                    winRate: 0,
                    avgGain: 0,
                    avgLoss: 0,
                    largestGain: 0,
                    largestLoss: 0
                };
            }

            update() {
                const closed = positionHistory.closed;
                if (closed.length === 0) return;

                const gains = closed.filter(p => p.gainLoss > 0);
                const losses = closed.filter(p => p.gainLoss < 0);
                
                this.metrics.winRate = (gains.length / closed.length) * 100;
                this.metrics.avgGain = gains.length > 0 ? 
                    gains.reduce((sum, p) => sum + p.gainLoss, 0) / gains.length : 0;
                this.metrics.avgLoss = losses.length > 0 ?
                    losses.reduce((sum, p) => sum + p.gainLoss, 0) / losses.length : 0;
                
                // Update UI
                document.getElementById('winRate').textContent = this.metrics.winRate.toFixed(1);
                document.getElementById('avgGain').textContent = this.metrics.avgGain.toFixed(2);
                document.getElementById('avgLoss').textContent = this.metrics.avgLoss.toFixed(2);
            }

            display(portfolio) {
                // Implementation of display method
            }
        }

        function draw() {
            background(20);
            
            // Apply transformations for pan, zoom, and rotation
            push();
            translate(width/2, height/2);
            scale(zoomLevel);
            rotate(rotation);
            translate(-width/2 + panX, -height/2 + panY);
            
            // Update and display all cells
            [...gainCells, ...lossCells].forEach(cell => {
                cell.update();
                cell.display();
            });
            
            // Update and display amoeba
            amoeba.update();
            amoeba.display();
            
            pop();
            
            // Only draw UI elements if they're not hidden
            if (!uiHidden) {
                // Update timeline and metrics
                timelineVisualizer.update();
                timelineVisualizer.display(portfolio.getHistory());
                performanceMetrics.update();
                performanceMetrics.display(portfolio);
            }
        }

        // Add global variable for UI visibility
        let uiHidden = false;

        function mouseDragged() {
            if (mouseButton === LEFT && !keyIsPressed) {
                // Pan when left mouse is dragged
                panX += movedX / zoomLevel;
                panY += movedY / zoomLevel;
            } else if (mouseButton === RIGHT || (mouseButton === LEFT && keyIsPressed && keyCode === SHIFT)) {
                // Rotate when right mouse is dragged or left mouse + shift
                rotation += movedX * 0.01;
            }
            return false;
        }

        function mouseWheel(event) {
            // Zoom in/out with mouse wheel
            const zoomSensitivity = 0.05;
            const newZoomLevel = zoomLevel * (1 - event.delta * zoomSensitivity * 0.01);
            
            // Constrain zoom level
            zoomLevel = constrain(newZoomLevel, 0.5, 5);
            
            // Adjust pan to zoom towards mouse position
            const mouseXBeforeZoom = (mouseX - width/2) / zoomLevel + width/2 - panX;
            const mouseYBeforeZoom = (mouseY - height/2) / zoomLevel + height/2 - panY;
            
            const mouseXAfterZoom = (mouseX - width/2) / newZoomLevel + width/2 - panX;
            const mouseYAfterZoom = (mouseY - height/2) / newZoomLevel + height/2 - panY;
            
            panX += (mouseXAfterZoom - mouseXBeforeZoom) * newZoomLevel;
            panY += (mouseYAfterZoom - mouseYBeforeZoom) * newZoomLevel;
            
            return false;
        }

        function mousePressed() {
            // Check for cell selection only when not panning/rotating
            if (!keyIsPressed && mouseButton === LEFT) {
                const mousePos = createVector(
                    (mouseX - width/2) / zoomLevel + width/2 - panX,
                    (mouseY - height/2) / zoomLevel + height/2 - panY
                );
                
                [...gainCells, ...lossCells].forEach(cell => {
                    if (cell.containsPoint(mousePos.x, mousePos.y)) {
                        selectedCluster = cell;
                        showClosePositionDialog(cell);
                    }
                });
            }
            
            return false;
        }

        function keyPressed() {
            if (key === 'h' || key === 'H') {
                // Toggle UI visibility
                uiHidden = !uiHidden;
                const uiElements = [
                    document.getElementById('portfolio-status'),
                    document.getElementById('metrics'),
                    document.getElementById('timeline'),
                    document.getElementById('closePositionDialog')
                ];
                uiElements.forEach(el => {
                    if (el) {
                        el.style.display = uiHidden ? 'none' : 'block';
                    }
                });
                // Keep instruction prompt visible unless explicitly hidden
                document.getElementById('instruction-prompt').style.display = 
                    uiHidden ? 'none' : 'block';
            } else if (key === 'm' || key === 'M') {
                // Toggle mouse following
                amoeba.followMouse = !amoeba.followMouse;
                amoeba.target = null;  // Clear current target when switching modes
            } else if (key === 'i' || key === 'I') {
                // Toggle instruction overlay
                const overlay = document.getElementById('instruction-overlay');
                const currentDisplay = overlay.style.display;
                overlay.style.display = currentDisplay === 'none' ? 'block' : 'none';
                
                // Hide the prompt when instructions are shown
                document.getElementById('instruction-prompt').style.display = 
                    currentDisplay === 'none' ? 'none' : 'block';
            }
        }

        function showClosePositionDialog(cluster) {
            const dialog = document.getElementById('closePositionDialog');
            document.getElementById('closeSymbol').textContent = cluster.position.symbol;
            document.getElementById('closeGainLoss').textContent = 
                '$' + cluster.position.gainLoss.toFixed(2);
            dialog.style.display = 'block';
        }

        function confirmClosePosition() {
            if (selectedCluster) {
                selectedCluster.startClosing();
            }
            document.getElementById('closePositionDialog').style.display = 'none';
        }

        function cancelClosePosition() {
            document.getElementById('closePositionDialog').style.display = 'none';
        }

        function saveHistory() {
            localStorage.setItem('positionHistory', JSON.stringify(positionHistory));
        }

        function loadHistory() {
            const saved = localStorage.getItem('positionHistory');
            if (saved) {
                const loaded = JSON.parse(saved);
                positionHistory = {
                    ...loaded,
                    open: loaded.open.map(p => new Position(p)),
                    closed: loaded.closed.map(p => new Position(p))
                };
                portfolio.updateValue();
                performanceMetrics.update();
            }
        }

        function updateDisplay() {
            const currentValue = portfolio.getCurrentValue();
            const totalGainLoss = portfolio.getTotalGainLoss();
            
            document.getElementById('currentValue').textContent = currentValue.toFixed(2);
            document.getElementById('totalGainLoss').textContent = totalGainLoss.toFixed(2);
            document.getElementById('positionCount').textContent = portfolio.positions.length;
        }

        // Prevent right-click menu
        document.addEventListener('contextmenu', event => event.preventDefault());
    </script>
</body>
</html> 
